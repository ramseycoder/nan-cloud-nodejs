#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('tester:server');
var http = require('http');
const path = require('path');
const rootDirectory = path.join(__dirname, '../STORAGE');
const fs = require('fs');
const rimraf = require('rimraf');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = require('socket.io').listen(server);
/**
 * Listen on provided port, on all network interfaces.
 */
io.on('connection', socket => {
  console.log('user connected');
  folder_path = "";
  try {
    socket.on('create_folder', async (data) => {
      if (folder_path === "") {
        fs.mkdirSync(path.join(rootDirectory, data), 775);
        fs.chmodSync(path.join(rootDirectory, data), 0o775)
        fs.readdir(rootDirectory, (err, files) => {
          const res = onSucces(files, folder_path);
          socket.emit('success', res.files, res.breadcrumb, false);
        })
      } else {
        const dir = rootDirectory + '/' + folder_path
        fs.mkdirSync(path.join(dir, data), 777);
        fs.chmodSync(path.join(dir, data), 0o775)
        fs.readdir(dir, (err, files) => {
          const res = onSucces(files, folder_path);
          socket.emit('success', res.files, res.breadcrumb, false);
        })
      }
    });

    socket.on('openFolder', async (data) => {
      let path2 = "";
      if (folder_path === "") {
        path2 = rootDirectory + `/${data}`;
        folder_path += data;
      } else if (folder_path.includes('/') && folder_path.split('/').includes(data)) {
        let Tab = folder_path.split('/');
        if (Tab.indexOf(data) === 0) {
          path2 = rootDirectory + `/${data}`;
          folder_path = data;
        } else {
          let link = Tab.slice(0, Tab.indexOf(data) + 1).join('/');
          path2 = rootDirectory + `/${link}`;
          folder_path = link;
        }
      } else {
        path2 = rootDirectory + `/${folder_path}/${data}`;
        folder_path += `/${data}`
      }
      fs.readdir(path2, (err, files) => {
        const res = onSucces(files, folder_path);
        socket.emit('success', res.files, res.breadcrumb, true);
      })
    });

    socket.on('reload', () => {
      fs.readdir(rootDirectory + `${folder_path === "" ? "": '/'+folder_path }`, (err, files) => {
        const res = onSucces(files, folder_path);
        socket.emit('success', res.files, res.breadcrumb, false);
      })
    })

    socket.on('delete', (data) => {
      let p = folder_path === "" ? rootDirectory + `/${data}` : rootDirectory + `/${folder_path}/${data}`;
      if (data.slice(verifPoint(data), data.length) !== data) {
        fs.unlinkSync(p)
        fs.readdir(rootDirectory + `${folder_path === "" ? "": '/'+folder_path }`, (err, files) => {
          const res = onSucces(files, folder_path);
          socket.emit('success', res.files, res.breadcrumb, false);
        })
      } else {
        rimraf.sync(p);
        fs.readdir(rootDirectory + `/${folder_path}`, (err, files) => {
          const res = onSucces(files, folder_path);
          socket.emit('success', res.files, res.breadcrumb, false);
        })
        /* var deleteFolderRecursive = function (p) {
          if (fs.existsSync(p)) {
            fs.readdirSync(p).forEach(function (file, index) {
              var curPath = path + "/" + file;
              if (fs.lstatSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath);
              } else { // delete file
                fs.unlinkSync(curPath);
              }
            });
            fs.rmdirSync(path);
          }
        }  */
      };

    })
  } catch (e) {

  }
})




function verifImage(str) {
  return ['jpg', 'png', 'gif', 'jpeg'].includes(getType(str));
}

function getType(str) {
  return str.slice(verifPoint(str) + 1, str.length);
}

function verifPoint(str) {
  const tab = [];
  for (let i = 0; i < str.length; i++) {
    if (str[i] === ".") {
      tab.push(i);
    }
  }
  return tab[tab.length - 1];
}

function onSucces(files, link) {
  let breadcrumb, pathZ;
  // breadcrumb
  if (!link.includes('/')) {
    breadcrumb = `<li onclick='location.reload();'><span> <i class='fas fa-folder'></i><span class='fdn'>root</span></span></li><li class='active'><span> <i class='fas fa-folder'></i> <span class='fdn'>${link}</span></span></li>`;
  } else {
    breadcrumb = "<li onclick='location.reload();'><span><i class='fas fa-folder'></i> <span class='fdn'>root</span></span></li>";
    link = link.split('/');
    for (let i = 0; i < link.length; i++) {
      if (i !== link.length - 1) {
        breadcrumb += `<li onclick="openfolderb(this)" ><span><i class='fas fa-folder'></i> <span class='fdn'>${link[i]}</span></span></li>`;
      } else {
        breadcrumb += `<li class='active' ><span><i class='fas fa-folder'></i> <span class='fdn'>${link[i]}</span></span></li>`;
      }
    }
  }
  //path
  if (files.length === 0) {
    pathZ = '<p>le dossier est vide</p>';
  } else {
    let div = "<ul>";
    files.forEach(donne => {
      let el = "";
      if (getType(donne) === donne) {
        el = '<li onclick="openfolder(this)" ><span class="arrow"><i class="fas fa-arrow-alt-circle-right"></i></span>';
      } else if (getType(donne) === "mp4") {
        el = '<li onmouseover="play(this)" onmouseout="stop(this)" onclick="fullscreen(this)"><span class="arrow"><i class="fas fa-arrow-alt-circle-right"></i></span>';
      } else {
        el = '<li><span class="arrow"><i class="fas fa-arrow-alt-circle-right"></i></span>';
      }
      if (getType(donne) === "mp4") {
        el += `<video width="200" height="100" muted loop="loop" controls="controls">
            <source src="${folder_path === "" ? '/STORAGE/'+donne+'' : '/STORAGE/'+folder_path+'/'+donne}#t=4,7" type="video/mp4" />
        </video>&nbsp;&nbsp;&nbsp;<span class="namev">${donne}</span>`;
      } else if (verifImage(donne)) {
        el += `<img src="/STORAGE/${folder_path === "" ? donne : folder_path+'/'+donne}" height="80">&nbsp;&nbsp;&nbsp;<span class="name">${donne}</span>`;
      } else if (getType(donne) === "mp3") {
        el += `<i class="fas fa-audio"></i>${donne}`;
      } else if (getType(donne) === donne) {
        el += `<i class="fas fa-folder"></i>&nbsp;&nbsp;&nbsp;<span class="name">${donne}</span>`;
      } else {
        el += `<i class="fas fa-file"></i>&nbsp;&nbsp;&nbsp;<span class="name">${donne}</span>`;
      }
      el += `${getType(donne) === donne || getType(donne) === 'mp4'  ? '<i class="fas fa-trash" onmouseenter="block()" onmouseleave="unblock()" onclick="supp(this)"></i>' : '<i class="fas fa-trash" onclick="supp(this)"></i>'} </li>`;
      div += el;
      el = '';
    });
    div += '</ul>';
    pathZ = div;
  }
  return {
    "breadcrumb": breadcrumb,
    "files": pathZ
  }

}

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string' ?
    'Pipe ' + port :
    'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ?
    'pipe ' + addr :
    'port ' + addr.port;
  console.log('Listening on ' + bind);
}